<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode0167-两数之和II-输入有序数组]]></title>
    <url>%2F2019%2F08%2F07%2Fleetcode0167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[问题描述给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。示例： 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路这个题也是个简单题，关键是思路。 与leetcode第一题：两数之和相比，这个题输入是有序数组，如何使用这一性质是优化的关键。 方法一：普通遍历因为是有序数组，所以我们可以双向遍历 取首尾两数相加 如果和目标值相等返回对应索引 如果大于目标值，尾索引减1 如果小于木编制，头索引加1 方法二：二分查找从首位置开始，依次进行二分查找 取nums[index]作为第一个加数，target-nums[index]为被加数 二分查找的范围为[index+1, nums.length-1] 若存在等于被加数的数，返回指定索引 若不存在index+1，继续下一轮遍历 代码实现代码一：普通遍历123456789class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: left, right, tmp = 0, len(numbers)-1, 0 for num in numbers: tmp = numbers[left] + numbers[right] if tmp == target: return [left+1, right + 1] if tmp &gt; target: right -= 1 if tmp &lt; target: left += 1 代码二：二分查找123456789101112131415161718192021class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: for left in range(len(numbers)): right = self.binarySearch(target-numbers[left], left + 1, numbers) if right != -1: return [left+1, right+1] def binarySearch(self, target: int, index: int, numbers: List[int]) -&gt; int: start, end = index, len(numbers)-1 while start &lt;= end: mid = start + (end - start) // 2; if numbers[mid] &lt; target: start = mid + 1 elif numbers[mid] &gt; target: end = mid - 1 else: return mid return -1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0226-翻转二叉树]]></title>
    <url>%2F2019%2F08%2F07%2Fleetcode0226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[问题描述翻转一棵二叉树。 示例： 输入： 12345 4 / \ 2 7 / \ / \1 3 6 9 输出： 12345 4 / \ 7 2 / \ / \9 6 3 1 备注：这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 解题思路方法一：递归记得刚开始学算法的时候感觉递归是最变态的，很多东西都想不清楚，尤其是不知道递归返回的时候到底返回的是什么，但是算法就实现了。但是当真正的了解了递归，你会发现很多题目使用递归是最直接的思路，题目的难度会大幅降低。 那本题来说，递归的结束条件应该是什么？ 首先当为空树的时候我们不进行任何操作 当只有根节点的时候我们也不进行任何操作 除此之外，都是将左右的节点交换 想完以上三个问题，代码的实现就非常简单了。 方法二：非递归的思路也不难，既然是交换左右子树的的位置，肯定是同行操作，所以应该用到是二叉树的层序遍历。 对于二叉树的层序遍历我们需要使用队列来辅助我们的遍历操作。 初始化一个队列，将根节点入列，循环判断队列是否为空，不为空时进行一下操作： 从队列中取出一个节点 交换该节点左右子树的位置 若该节点存在左子树，则左子树入列 若该节点存在右子树，则右子树入列 队列为空，结束遍历，返回结果即可 代码实现代码一：递归1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: # 空树 if not root: return root # 左右子树都为空，只有根节点 if not root.left and not root.right: return root # 交换左右子树 root.left, root.right = root.right, root.left # 递归左子树 self.invertTree(root.left) # 递归右子树 self.invertTree(root.right) return root 代码二：非递归123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: from queue import Queue # 空树 if not root: return root # 只有根节点 if not root.left and not root.right: return root # 初始化队列 q = Queue() q.put(root) while not q.empty(): tmp = q.get() # 交换左右子树 tmp.left, tmp.right = tmp.right, tmp.left # 左子树不为空入列 if tmp.left: q.put(tmp.left) # 右子树不为空入列 if tmp.right: q.put(tmp.right) return root]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0024-两两交换链表中的节点]]></title>
    <url>%2F2019%2F08%2F06%2Fleetcode0024-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[问题描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 解题思路这个题其实是考察链表的基本操作，不应该算中等题。 注意头结点的变换，注意保持前一节点的位置，注意判空就好了。 类似于链表的题多在纸上画一画，一边都能得出答案。 代码实现12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* swapPairs(struct ListNode* head)&#123; struct ListNode* res = (struct ListNode*)malloc(sizeof(struct ListNode)); res-&gt;next = head; struct ListNode* pre = res; struct ListNode* p = head; struct ListNode* q; while(NULL != p &amp;&amp; NULL != p-&gt;next)&#123; q = p-&gt;next; p-&gt;next = q-&gt;next; pre-&gt;next = q; q-&gt;next = p; pre = p; p = p-&gt;next; &#125; return res-&gt;next;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0011-盛水最多的容器]]></title>
    <url>%2F2019%2F08%2F06%2Fleetcode0011-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[问题描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路有一种最简单的方法，双遍历暴力求解，这显然不应该使我们应该考虑使用方法，其时间复杂度是O(n²) 能不能在一次遍历中就找到最大值呢，答案是可以的。 首先我们确定，这个题其实是在求最大矩形面积。矩形的面积等于底乘以高。$ S = d * h $ 在底相同的情况下，影响矩形面积的是短边的高度，类似于木桶理论，一个木桶盛多少水，取决于短板的高度。 初始时，我们给出最大底边长，计算该底边下的最大面积，然后我们移动短边到下一个位置，再计算当前情况下的最大面积，比较两个面积，取最大值，然后一直遍历下去，就可以得到最大面积。 这里可能会有一点不明白，为什么移动短边，而不是移动长边？稍微想一下就可以回答这个问题。如果我们移动长边，短边不变，那我们取到的短边会越来越短，只有移动长边，才能保证取到较长的边。 这里有一位大神给出了严格的证明过程，大家可以参考一下。 证明假设：该算法并没有遍历到容量最大的情况 我们令容量最大时的指针为p_left和p_right。根据题设，我们可以假设遍历时左指针先到达p_left，但是当左指针为p_left时，右指针还没有经过p_right左指针就移动了 已知当左指针停留在p_left时，它只有在两种场景下会发生改变 左指针和右指针在p_left相遇，则右指针一定在前往p_left的途中经过p_right，与题设矛盾 右指针位于p_right右侧且当前的值大于左指针。则在这种情况下，此时容器的盛水量比题设中最大的盛水量还要大，与题设矛盾 因此该算法的遍历一定经过了最大的盛水量的情况 代码实现1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int maxArea(int* height, int heightSize);int main(int argc, char const *argv[])&#123; int height[] = &#123;1,8,6,2,5,4,8,3,7&#125;; int heightSize = 9; int res = maxArea(height, heightSize); printf("最多盛水: %d\n", res); return 0;&#125;int maxArea(int* height, int heightSize)&#123; int max = 0, tmp = 0; int left = 0, right = heightSize-1; int h = 0, d = 0; while(left &lt; right)&#123; d = right-left; // 取短边为高，并且移动短边到下一位置 if(height[left] &gt; height[right])&#123; h = height[right]; right--; &#125;else&#123; h = height[left]; left++; &#125; tmp = d * h; if(tmp &gt; max) max = tmp; &#125; return max;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c语言</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实战2——K-近邻算法]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%982%E2%80%94%E2%80%94K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[文末有本书的PDF电子版，仅供学习交流使用，毕竟做笔记写代码还是电子书方便一点。提倡大家去购买正版图书。 K-近邻算法简述K-近邻算法(kNN)简单而有效，采用测量不同特征值之间的距离来进行分类。 优点：精度高、对异常值不敏感、无数据输入假定。 缺点：计算复杂度高、空间复杂度高。 适用数据范围：数值型和标称型 工作原理：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据(最近邻)的分类标签。一般来说，我们只选择样本集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出出现次数最多的分类，作为新数据的分类。 距离的测量K-近邻算法在分类过程中通过判断数据之间的欧氏距离来判定未知数据属于哪一个分类。 简单介绍一下欧式距离。我们中学都学过两点距离公式：$ d=\sqrt{(x_1 - x_2)^2+(y_1 - y_2)^2} $，$x,y$表示空间坐标 这个公式我们还可以展开到三维空间：$d=\sqrt{(x_1 - x_2)^2+(y_1 - y_2)^2+(z_1 - z_2)^2}$ 同样的我们可以将该公式一直展开到n维空间，这就是欧氏距离的计算公式：d = $ \sqrt{\sum_{i=1}^{n}(x_i-y_i)^2} $ k-近邻算法的一般流程 收集数据：可以使用任何方法 准备数据：距离计算所需要的数值，最好是结构化的数据格式 分析数据：分析使用任何方法 训练算法：此步骤不适用于k-近邻算法 测试算法：计算错误率 使用算法：首先需要输入样本数据和机构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后序的处理。 实战演练纸上得来终觉浅，绝知此事要躬行。 上面写了一堆理论性的东西，其实就是把《机器学习实战》这本书第二章讲的内容概括了一下。想要更好的了解这个算法，我们还是来看两个例子。 电影分类不知道大家是不是喜欢看电影，我还是比较喜欢看电影的，如果有空闲下来，去电影院看个电影是不错的选择。我一般喜欢喜剧片、科幻片和动作片。但是这里我还是老老实实套用书里讲的爱情片和动作片的分类好了。 我们知道的功夫巨星如成龙，李连杰，吴京等，看他们的电影，你会发现其中打斗的场景特别多，生死看淡不服就干，但是一些爱情片如前任1，前任2，前任3(活了这么大也没个前任，甚是可悲)，这类电影吻戏会比较多。我们把吻戏的镜头和动作戏的镜头作为指标，衡量一部电影到底是爱情片还是动作片，爱情动作片不在考虑范围内，这个太为难我们的算法了(这个问题感兴趣的我们可以私下交流🙄🙄🙄)。 准备数据为了简化过程，这里我们只假定四条数据，两条爱情片，两条动作片。 1234567891011121314151617181920212223242526272829import numpy as np"""函数说明:创建数据集 @returns: group: 数据集 labels: 分类标签"""def createDataSet(): #四组二维特征 features = np.array([[1,101],[5,89],[108,5],[115,8]]) #四组特征的标签 labels = ['爱情片','爱情片','动作片','动作片'] return features, labelsdef main(): features, labels = createDataSet() print("数据集：") print(features) print("标签：") print(labels)if __name__ == '__main__': main() 下面运行结果，我使用的是sublime，配置了python开发环境，直接在sublime下执行的。 为了更直观的显示爱情片和动作片在空间上差异，我们使用matplotlib这个库，将上面的坐标画出来： 12345678910111213141516171819"""函数说明: 绘制坐标示意图 @params: features: 特征值集合"""def drawPicture(features): # 导入matplotlib下的绘图工具 import matplotlib.pyplot as plt # 数据集中的第一维是x轴，数据集中的第二维是y轴 x, y = features[:, 0], features[:, 1] # 初始化 fig, ax = plt.subplots() # 设置数据: 爱情片用红色表示，动作片用蓝色表示 ax.scatter(x[:2], y[:2], color='red') ax.scatter(x[2:], y[2:], color='blue') plt.show() 如下图所示: 即使不使用算法，从感官上看，未知点靠进红色点时，应该被标记为红色，即爱情片；未知点靠进蓝色点时，应该被标记为蓝色，即动作片。 k-近邻算法实现带有标签的数据集我们已经准备好了，接下来是实现算法。对新给入的数据将其依次与已知数据距离计算，得到新数据距离已有数据的距离。然后从这些距离中找出最小的k个，统计这k个数的分类情况，最多的类作为新数据的分类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152"""函数说明: kNN算法，分类器 @params: inX: 用于分类的数据(测试集) dataSet: 用于训练的数据(训练集) labes: 分类标签 k: kNN算法参数,选择距离最小的k个点 @returns: sortedClassCount[0][0]: 分类结果"""def classify0(inX, dataSet, labels, k): # 训练集有多少条数据 dataSetSize = dataSet.shape[0] # 将inX在横向复制1次，纵向复制dataSetSize次 # 这样就得到了一个和训练集形状相同的测试数据集 dataMat = np.tile(inX, (dataSetSize, 1)) # 矩阵之间做减法，求特征值之间的差值 diffMat = dataMat - dataSet # 差值的平方 sqDiffMat = diffMat**2 # 累加得到距离的平方 sqDistances = sqDiffMat.sum(axis=1) # 开方，计算出距离 distances = sqDistances**0.5 # 返回distances中元素从小到大排序后的索引值 sortedDistIndices = distances.argsort() # 定一个记录类别次数的字典 classCount = &#123;&#125; for i in range(k): # 取出前k个元素的类别 voteIlabel = labels[sortedDistIndices[i]] # dict.get(key,default=None),字典的get()方法,返回指定键的值,如果值不在字典中返回默认值。 # 计算类别次数 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 # python3中用items()替换python2中的iteritems() # key=operator.itemgetter(1)根据字典的值进行排序 # key=operator.itemgetter(0)根据字典的键进行排序 # reverse降序排序字典 sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True) # 返回次数最多的类别,即所要分类的类别 return sortedClassCount[0][0] 下面我们就测试这个算法，看看它能不能像我们想的那样，给未知的电影进行分类。 我们使用inX = [10, 107]作为测试数据，这不电影里面吻戏居多，应该是一部爱情片。 从上面的执行结果我们可以看出，分类器很好的完成了自己的工作。对于吻戏居多的电影分为爱情片。 我们可以多测试数据： 测试数据: [107, 10] 的分类结果是: 动作片 测试数据: [50, 50] 的分类结果是: 爱情片 测试数据: [100, 100] 的分类结果是: 动作片 从上面的例子我们可以看出，这个分类器是无法分出爱情动作片的。 k-近邻算法实战之约会网站配对效果判定待更新 附《机器学习实战》电子版《机器学习实战》链接:https://pan.baidu.com/s/1opjVllNBf1WMVcNWJ5NzYg 密码:s6h8]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>k-近邻算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0169-求众数]]></title>
    <url>%2F2019%2F08%2F05%2Fleetcode0169-%E6%B1%82%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 12输入: [3,2,3]输出: 3 示例 2: 12输入: [2,2,1,1,1,2,2]输出: 2 解题思路这个题的技法有很多，最简单的一种就是遍历数组，统计每个元素出现的次数，返回统计次数最多的元素，想法最简单，但是性能并不好，时间复杂度和空间复杂度都很高。稍微想一下，看一下题目中的条件，众数是指在数组中出现次数超过[n/2]的元素，如果我们将数组排序，中间的元素必然是众数，这样就把时间复杂度降到了O(n·logn)，空间复杂度为O(1)。 其实还有一种更好的解决方案：摩尔投票法 该算法的时间复杂度是O(n)，空间复杂度是O(1)，是已知最后的解决方案。 代码实现12345678910111213141516171819int majorityElement(int* nums, int numsSize)&#123; int res = 0, tmp = 0; for(int i = 0; i &lt; numsSize; i++)&#123; if(tmp == 0)&#123; res = *(nums+i); tmp = 1; &#125;else if(res == *(nums+i))&#123; tmp++; &#125;else&#123; tmp--; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c语言</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0160-相交链表]]></title>
    <url>%2F2019%2F08%2F04%2Fleetcode0160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路这个题最大的障碍在于两个链表不等长，如果等长，我们只许挨个比较指针地址就可以了，第一个相等的就是交点。所以思路有很多种。 方法1 遍历链表a和链表b，求出他们的长度差m 再次遍历，这次遍历时先让长链多走m，然后再同时开始，第一个相等的就是交点 方法2我们都学过加法交换律，a+b = b+a 所以A链长+B链长等于B链长+A链长 同时遍历A和B连个链表 当代理指针a为空时指向B链 当代理指针b为空时指向A链 这样A+B和B+A最后一部分肯定是相等的，第一个相等的节点就是交点 代码实现123456789101112131415161718192021222324252627/** * 这里我们只实现了方法2的代码 * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123; struct ListNode *a = headA; struct ListNode *b = headB; while(a != b)&#123; if(NULL != a) a = a-&gt;next; else a = headB; if(NULL != b) b = b-&gt;next; else b = headA; &#125; return a;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0142-环形链表II]]></title>
    <url>%2F2019%2F08%2F04%2Fleetcode0142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%2F</url>
    <content type="text"><![CDATA[问题描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回null。 为了表示给定链表中的环，我们使用整数 pos来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果pos是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例2： 123输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路参考了知乎的一篇文章——【LeetCode】142#环形链表2 思路一定还是快慢指针。只是如何找到其中的关系，确认入环的节点是哪一个。 首先我们假设链表中有环存在，这只一个快指针fast和慢指针slow，这两个指针在最开始都指向初始位置head，slow的速度是1，fast的速度是2，fast的速度是slow的两倍，在相同的时间下，fast的移动距离是slow的两倍。 如图所示： A为起点，B是入环点，C是相遇点 x是到入环的距离，y+z是一圈的距离 第一次在C点相遇时，slow走了x+y，fast走了x+y+z+y 快指针是慢指针距离的两倍，所以有2(x+y) = x+y+z+y 解上面的等式有x=z 所以当快慢指针在C点相遇后，由于x=z，如果我们把其中一个指针放在A，另一个还在C，此时以相同的速度前进，他们就会在B点相遇，而B点就是我们要求的入环点 代码实现12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *detectCycle(struct ListNode *head) &#123; if(NULL == head || NULL == head-&gt;next) return NULL; struct ListNode * slow = head; struct ListNode * fast = head; while(NULL != fast-&gt;next &amp;&amp; NULL != fast-&gt;next-&gt;next)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) &#123; slow = head; while(slow != fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; &#125;; &#125; return NULL;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实战1——机器学习基础]]></title>
    <url>%2F2019%2F08%2F03%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%981%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[​ 重新学习《机器学习实战》这本书，作为机器学习入门来说，这本书真的很不错，理论和实际相结合，可以快速上手代码，体验算法的实现过程。目标是把这本书的每一章概要都摘录出来，算是自己的学习笔记吧。文末有本书的PDF电子版，仅供学习交流使用，毕竟做笔记写代码还是电子书方便一点。提倡大家去购买正版图书。 简述机器学习能让我们自数据集中受到启发，换句话说，我们会利用计算机来彰显数据背后的真实含义，这才是机器学习的正式含义。 应用场景举例： 改善商业决策 提高生成率 检测疾病 预测天气 人脸识别 垃圾邮件分类 个性化商品推荐 何谓机器学习机器学习就是把无序的数据转换成有用的信息。 机器学习对于任何需要解释并操作数据的领域都有所裨益。 机器学习用到了统计学的知识。 当我们不能建立一种精确模型时，我们可以参照现实世界中存在的这种实例，运用统计学工具去解决这类问题。 传感器和海量数据非人为数据：传感器采集的数据 移动计算和传感器产生的海量数据意味着未来我们将面临着越来越多的数据，如何从海量数据中抽取到有价值的信息将是一个非常重要的可以。 机器学习非常重要针对具体任务搞懂所有相关数据的意义所在，这正成为基本的技能要求。 机器学习有助于我们穿越数据的迷雾，从中抽取到有用的信息。 关键术语特征：也称为属性，特征值可以是数值型，二值型（是或不是一类只有两个值，一般取0，1），枚举型等。特征或者属性通常是训练样本集的列，它们是独立测量得到的结果。多个特征联系在一起共同组成一个训练样本。 目标变量：机器学习算法的预测结果，在分类算法中目标变量的类型通常是标称型的，在回归算法中通常是连续型的。 训练集：已经处理过的数据，根据任务的不同，数据的处理方式也不尽相同。训练集必须有明确的目标变量的值，以便机器学习算法可以发现特征和目标变量之间的关系。 训练样本：训练集中的单条记录 训练数据：通过训练数据作为算法输入训练模型 测试数据：训练结束后输入测试数据，验证训练结果。输入测试数据时并不输入测试样本的目标变量，而是有程序自身去判定。 知识表示：某些算法可以产生很容易理解的知识表示，某些算法的知识表示也许只有计算机可以理解。知识表示可以采用规则集的形式，也可以采用概率分布的形式，甚至可以是训练样本集中的一个实例。 监督学习：必须知道分类结果或者预测结果是什么，即目标标量的分类信息。 无监督学习：数据没有类别信息，也不会给定目标值。 机器学习的主要任务机器学习的主要任务是分类和回归。 回归主要用于预测数值型数据。 分类和回归都属于监督学习。 无监督学习的主要任务是聚类和密度估计。无监督学习还可以减少数据特征的维度，以便我们可以使用二维或三维图形更加直观的展示数据。 聚类：将数据集合分成由类似的对象组成的多个类的过程被称为聚类 密度估计：将寻找描述数据统计值的过程称之为密度估计。 如何选择合适的算法选择哪种算法取决于以下两个问题： 使用机器学习算法的目的，想要算法完成何种任务。 预测目标变量的值选择监督学习算法，否则选择无监督学习算法。 在监督学习算法中，如果目标变量是离散型，可以选择分类算法，如果目标值是连续型的数值，需要选择回归算法。 再无监督学习中，分析是否需要将数据划分为离散的组，如果是，则选择聚类算法。如果还需要估计数据与每个分组的相似程度，则需要使用密度估计算法。 需要分析或者收集的数据是什么 了解数据的特性 特征值是离散型变量还是连续型变量 特征值中是否存在缺失的值，何种原因造成缺失 数据中是否存在异常值 某个特征发生的频率如何 开发及其学习应用程序的步骤 收集数据 网络爬虫 设备反馈，各类传感器 公开的数据源 准备输入数据 得到数据之后，还必须保证数据格式符合要求。需要为机器学习算法准备特定的数据格式，如某些特征值使用特定的格式，一些算法要求目标变量和特征值是字符串类型，而另一些算法可能要求是整数类型。 分析输入数据 此步骤主要是人工分析以前得到的数据。这一步的主要作用是确保数据集中没有垃圾数据。 训练算法 第4步和第5步是机器学习算法的核心。我们将前两步得到的格式化数据输入到算法，从中提取知识或信息。这里得到的知识需要存储为计算机可以处理的格式。 在无监督学习中，由于不存在目标变量之，故而也不需要训练算法，所有与算法相关的内容都集中在第5步。 测试算法 这一步将实际使用步骤4得到的知识信息。为了评估算法，必须测试算法工作的效果。对于监督学习，必须已知用于评估算法的目标变量值；对于无监督学习，也必须使用其他评测手段来检验算法的成功率。 使用算法 将机器学习的算法转换为应用程序，执行实际任务。 Python语言的优势基于以下三个原因： python语法清晰 易于操作纯文本文件 使用广泛，存在大量的开发文档 可执行伪代码Python比较流行 SciPy NumPy Matplotlib Python语言的特色Python语言的缺点性能不足，执行效率没有C或者Java快。 附《机器学习实战》电子版《机器学习实战》链接:https://pan.baidu.com/s/1opjVllNBf1WMVcNWJ5NzYg 密码:s6h8]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0141-环形链表]]></title>
    <url>%2F2019%2F08%2F03%2Fleetcode0141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路刚开始读这个题的时候读了半天没读懂，最后明白了，和pos就没有关系，输入中没有pos，就是判断链表是不是环形链表。 首先明确什么是环形链表，连接给出的是循环链表的定义，环形链表就是尾指针不一定要指向头结点，可以指向其他结点。只要为指针指向了链表中的一个节点就构成了环形链表。 如何判断有环呢？一般学校都会有操场，中间都会有一个400米的跑道。想象一下有两个人在起点开始赛跑，假定两个人体力无限，就一直跑下去，跑得快的人一定会追上跑的慢的人，因为跑的快的比跑的慢的多跑了一圈。 参考赛跑，我们给出两个指针： 慢指针：一个每次向后移动一步 快指针：一个每次向后移动两步 如果两个指针能够相遇，说明链表中存在环。 代码实现1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */bool hasCycle(struct ListNode *head) &#123; if(NULL == head || NULL == head-&gt;next) return 0; struct ListNode * slow = head; struct ListNode * fast = head; while(NULL != fast-&gt;next &amp;&amp; NULL != fast-&gt;next-&gt;next)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow-&gt;val == fast-&gt;val) return 1; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0119-杨辉三角II]]></title>
    <url>%2F2019%2F08%2F03%2Fleetcode0119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II%2F</url>
    <content type="text"><![CDATA[问题描述给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例： 12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路这个题和杨辉三角没有太大的区别，空间复杂为O(k)无非是要求大家本地操作。 代码实现123456789class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: res = [] for i in range(rowIndex+1): res.insert(0, 1) for j in range(1, i): res[j] = res[j] + res[j+1] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0349-两个数组的交集]]></title>
    <url>%2F2019%2F08%2F03%2Fleetcode0349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[问题描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2: 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 解题思路1遍历数组1，看数组1中的元素是否在数组2中，如果不在，判断该元素是否在返回结果中，不在，则添加到返回结果中。 代码实现112345678class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: res = [] for a in nums1: if a in nums2 and a not in res: res.append(a) return res 解题思路2python3运行第一的代码，使用了set去重，然后两个集合取交集。 代码实现2123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1)&amp;set(nums2))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0231-2的幂]]></title>
    <url>%2F2019%2F08%2F03%2Fleetcode0231-2%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[问题描述给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 123输入: 1输出: true解释: 20 = 1 示例 2: 123输入: 16输出: true解释: 24 = 16 示例 3: 12输入: 218输出: false 解题思路我们知道，在计算机的底层，所有的计算都是通过二进制来实现的。左移一位，相当于乘以2，右移一位，相当于除以2。并且位运算的执行效率是最高的。 代码实现12345678910111213class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: if n == 1 or n == 2: return True std = 2 while True: std = std&lt;&lt;1 if std == n: return True if std &gt; n: return False]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2019%2F08%2F02%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[递归法递归思想在二叉树的遍历过程中，思想是非常简单的。前中后分别对应的是树的根节点在什么时候被访问而决定的： 前序：最先访问根节点，然后访问左子树，最后访问右子树 中序：最先访问左子树，然后访问根节点，最后访问右子树 后序：最先访问左子树，然后访问右子树，最后访问根节点 对于一棵二叉树而言，其根节点往下的左孩子和右孩子分别是其左子树和右子树的根节点。所以在上面的描述中使用根节点描述中间节点。 前序先访问根节点，然后访问左子树，最后访问右子树 12345678def frontPrint(root): ''' 递归前序遍历 ''' if root: print(root.val, end=' ') frontPrint(root.left) frontPrint(root.right) 中序先访问左子树，然后访问根节点，最后访问右子树 12345678def midPrint(root): ''' 递归中序遍历 ''' if root: midPrint(root.left) print(root.val, end=' ') midPrint(root.right) 后序先访问左子树，然后访问右子树，最后访问根节点 12345678def behindPrint(root): ''' 递归后序遍历 ''' if root: behindPrint(root.left) behindPrint(root.right) print(root.val, end=' ') 迭代法对于迭代法而言，我们一般借助数据结构堆栈来实现对二叉树的遍历。这里我们只要弄清左中右三个节点(左子树，根节点，右子树)应该如何进栈就ok了。 这里我们在简单的描述一下堆栈：堆栈是一种数据结构，原则是先进后出，对于这种数据结构比较形象的实物描述是弹夹。对于弹夹而言，当我们往里压子弹的时候，最先压进去的子弹，最后被射出。堆栈就是这样一种数据结构，最先进栈的元素，最后出栈。 有了上面对于堆栈的基本描述，我们就可以比较清晰的分析前中后三种遍历的迭代实现了。 前序对于前序遍历，我们最先访问的是根节点，然后访问左子树，最后访问右子树。借助堆栈，想要达到这样的效果，我们应该保证右子树最先进栈，其顺序应该为右左中，这样出栈的时候就是中左右。 但是我们还可以换一种思想，我们每次可以先入栈根节点，这样的话根节点一直在栈顶，这时候我们将其出栈访问，根节点就不用参与之后的操作了。这样我们每次只要保证其右子树比左子树先进栈就可以了，由三者顺序入栈变为二者顺序入栈。这样就简单了很多。 12345678910111213141516171819202122def fPrint(root): ''' 迭代前序遍历： ''' # 空树 if not root: return None # 初始化堆栈 stack = list() # 入栈根节点 stack.append(root) # 堆栈不为空 while stack: # 出栈对顶元素 p = stack.pop() # 访问 print(p.val, end=' ') # 右子树存在，入栈右子树 if p.right: stack.append(p.right) # 左子树存在，入栈左子树 if p.left: stack.append(p.left) 中序对于中序遍历而言，最左节点最先被访问，所以我们可以从根节点开始将左子树不断入栈，一直到最左节点，然后出栈访问，然后去访问其右子树就可以。 当你找到最左几点，此时其左子树为空，所以其左子树不会入栈，出栈的对顶元素就是最下面这棵二叉树的根节点，访问之后再访问右子树，右子树不为空会继续入栈，为空继续出栈访问，不断的迭代。这里的说明是为了解决部分同学无法理解为什么没有看到根节点的访问过程。 12345678910111213141516171819202122def mPrint(root): ''' 迭代中序遍历 ''' # 空树 if not root: return None # 初始化堆栈 stack = list() # 设置访问指针 p = root while stack or p: if p: # 节点不为空一直向左继续入栈 stack.append(p) p = p.left else: # 出栈栈顶元素 p = stack.pop() # 访问 print(p.val, end=' ') # 准备访问右子树 p = p.right 后序后序迭代遍历相对于前序和中序稍微复杂一点，因为根节点是在第二次经过时被访问的。所以需要有一个辅助标记，标记节点是否是第二次被经过。 12345678910111213141516171819202122232425262728293031323334def bPrint(root): ''' 迭代后序遍历 ''' if not root: return None # 初始化堆栈 stack = list() # 初始化标记堆栈 arr = list() # 操作指针 p = root while stack or p: if p: # 入栈左子树 stack.append(p) # 使用False标记其是第一次被经过 arr.append(False) p = p.left else: # 出栈对顶元素 p = stack.pop() # 出栈标记 f = arr.pop() if p and f: # 第二次被访问 print(p.val, end=' ') p = None else: # 第一次被访问，重新入栈 stack.append(p) # 使用True标记第二次被经过 arr.append(True) # 准备访问其右子树 p = p.right]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0235-二叉搜索树的最近公共祖先]]></title>
    <url>%2F2019%2F08%2F02%2Fleetcode0235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[问题描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 1所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路这里首先需要弄清楚两个定义，一个是什么是二叉搜索树，一个是什么是最近公共祖先。 二叉搜索树：二叉搜索树也称二叉排序树，它要么是一棵空树，要么具有以下性质 若左子树不为空，则左子树上所有结点的值均小于它的根节点的值 若右子树不为空，则右子树上所有结点的值均大于它的根节点的值 它的左右子树也分别是二叉排序树 最近公共祖先：对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。 明确以上两个概念，我们可以从二叉搜索树的定义出发，得到一个递归解决方案： 根节点大于pq两个结点，则最近公共祖先在左子树 根节点小于pq两个结点，则最近公共祖先在右子树 否则根结点为最近公共祖先 代码实现1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if root.val &gt; p.val and root.val &gt; q.val: return self.lowestCommonAncestor(root.left, p, q) if root.val &lt; p.val and root.val &lt; q.val: return self.lowestCommonAncestor(root.right, p, q) return root]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0107-二叉树的层次遍历II]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode0107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II%2F</url>
    <content type="text"><![CDATA[问题描述给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7], 123453/ \9 20 / \ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 解题思路本题属于二叉树的基本操作，是二叉树的层次遍历。想要收集自底向上的遍历结果，只需要在自顶向下遍历完成时，将此层的遍历结果插入到结果list的最前面就可以了。 代码实现1234567891011121314151617181920212223242526def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: queue = collections.deque() result = [] queue.append(root) while queue: size = len(queue) current_list = [] for i in range(0, size): node = queue.popleft() if node: current_list.append(node.val) queue.append(node.left) queue.append(node.right) if current_list: result.insert(0, current_list) return result]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-0108将有序数组转换为二叉搜索树]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode0108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[问题描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 12345 0 / \ -3 9 / /-10 5 解题思路这个题主要是考察二叉平衡树的性质已经建树的过程，递归的思路是非常简单的 找到中间节点作为根 mid左侧作为左子树数组，递归调用生成左子树 mid右侧作为右子树数组，递归调用生成右子树 代码实现12345678910111213class Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: if not nums: return None if len(nums) == 1: return TreeNode(nums[0]) s, e = 0, len(nums)-1 mid = (s + e) // 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0038-报数]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode0038-%E6%8A%A5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123456781. 12. 113. 214. 12115. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。 11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。 21 被读作 &quot;one 2&quot;, &quot;one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 12输入: 1输出: &quot;1&quot; 示例 2: 12输入: 4输出: &quot;1211&quot; 解题思路​ 第一次做这个题的时候感觉这是正常人出的题吗。。。 ​ 说读不明白题的小伙伴，在看一下题目描述，你可以这样认为，除了第一行以外，其他的都是对钱一行的描述，比如第二行11是对第一行1的描述，第一行有“一个一”，依次往下读就好了。题目就是让我们读数。 ​ 其实通过上面的解读，我们可以很容易的发现，这个题明显符合递归的要求，终止于n=1，其他依次递归读数。但是在实现过程中我还是放弃了递归的方法，暴力求解。排名第一的算法使用的恰恰是递归。这里先说暴力求解。 n=1时，结果是1 n大于1时，设定pre为上一次读数结果，pre初值为n=1时的结果，所以设置pre=&quot;1&quot; 在c语言中，没有字符串的概念，字符串是通过字符数组的形式来表现的，字符串结束的标志是&#39;\0&#39;，所以在遍历过程中我们使用&#39;\0&#39;作为字符串结束的标志。 当前字符等于下一个字符时，count加1 当前字符不等于下一个字符时，将count以字符的形式链到结果上，并将当前字符一起链接，count归1 依次遍历 描述的不是很清楚，各位大佬凑合着看吧。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char * countAndSay(int n);// 排名第一的代码char * countAndSayNo1(int n);char * countHelper(char *s, int n);int main(int argc, char const *argv[])&#123; /* code */ int n = 3; char* res = countAndSay(n); printf("%s\n", res); return 0;&#125;char * countAndSay(int n) &#123; char* last = (char*)calloc(5000, sizeof(char)); char* now = (char*)calloc(5000, sizeof(char)); last[0] = '1'; if(n == 1) &#123; free(now); return last; &#125; int i = 1, j = 0, count = 0, index = 0, len = 1; while(i &lt; n) &#123; count = 1; index = 0; for(j = 0; j &lt; len; j++) &#123; if(last[j] == last[j + 1])&#123; count++; &#125;else&#123; // 将数字count转换为字符数组，'0'的asc码加count值等于对应数字的asc码 now[index++] = '0' + count; now[index++] = last[j]; count = 1; &#125; &#125; now[index] = '\0'; len = index; // 将本次结果变为last memcpy(last, now, index * sizeof(char)); i++; &#125; free(last); return now;&#125;char * countAndSayNo1(int n)&#123; return countHelper("1", n);&#125;char * countHelper(char *s, int n)&#123; if (n == 1)&#123; return s; &#125;else&#123; //求下一个数 int count; char ch[10000]; char *p = ch; //一直读数 while (*s!='\0')&#123; count = 1; //如果一直是同一个数 while (*s==*(s+1))&#123; count++; s++; &#125; //下一个数更新 *p++ = (char)(count+'0'); *p++ = *s++; &#125; return countHelper(ch, n - 1); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>C语言</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leeetcode0069-x的平方根]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode0069-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[问题描述实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路 直接循环，找到第一个比x小的整数平方 二分查找 牛顿法 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;int mySqrt(int x);// 排名第一的代码int mySqrtNo1(int x);// 牛顿法int mySqrtNewton(int x);int main(int argc, char const *argv[])&#123; /* code */ return 0;&#125;/** * 不用动脑子，直接循环的方案 * 首先当x为0或者1时，返回其自身，这里条件说明了，x为非负数，如果没有说明，还应该判定负数。 * 然后就是循环遍历的问题了，知道知道一个大于等于x的平方数。 */int mySqrt(int x)&#123; if(x == 0 || x == 1) return x; long start = 1; long mul = 0; while(1)&#123; ++start; mul = start * start; if(mul &gt; x)&#123; --start; break; &#125;else if(mul == x)&#123; break; &#125; &#125; return start;&#125;/** * 这里的主要思想是折半查找或者是二分法 * 每次遍历缩小一半的空降，提升查找速度 */int mySqrtNo1(int x)&#123; if (x==1 || x==0) return x; int left = 0, right = x-1, mid; while(left &lt;= right)&#123; mid = left + (right - left)/2; if(mid==0) return 1; if(x/mid == mid) return mid; else if (x/mid &gt; mid) left = mid + 1; else if(x/mid &lt; mid) right = mid -1; &#125; return right; &#125;/** * 牛顿法 */int mySqrtNewton(int x)&#123; long r = x; while (r*r &gt; x) r = (r + x/r) / 2; return r;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>C语言</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0086-分割链表]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode0086-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解题思路题目虽说标记为中等，但其实并不难。主要就是考察指针的基本操作。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 定义链表节点struct ListNode &#123; int val; struct ListNode *next;&#125;;// 根据数组生成链表struct ListNode* createListNode(int* nums, int numsSize);// 打印链表void printListNodeVal(struct ListNode* head);// 分割链表struct ListNode* partition(struct ListNode* head, int x);// 排名第一的代码struct ListNode* partitionNo1(struct ListNode* head, int x);int main(int argc, char const *argv[])&#123; /* code */ int nums[] = &#123;1, 4, 3, 2, 5, 2&#125;; int x = 3; struct ListNode* root = createListNode(nums, 6); printListNodeVal(root); printf("\n"); struct ListNode* res = partition(root, x); printListNodeVal(res); return 0;&#125;struct ListNode* createListNode(int* nums, int numsSize)&#123; // 初始化第一个节点 struct ListNode* root = (struct ListNode*)malloc(sizeof(struct ListNode)); root-&gt;val = nums[0]; root-&gt;next = NULL; // 操作指针 struct ListNode* p; struct ListNode* n; p = root; for(int i = 1; i &lt; numsSize; i++)&#123; n = (struct ListNode*)malloc(sizeof(struct ListNode)); n-&gt;val = nums[i]; n-&gt;next = NULL; p-&gt;next = n; p = p-&gt;next; &#125; return root;&#125;void printListNodeVal(struct ListNode* head)&#123; struct ListNode* p = head; while(NULL != p)&#123; printf("%d", p-&gt;val); p = p-&gt;next; &#125;&#125;struct ListNode* partition(struct ListNode* head, int x)&#123; // 小于x的部分 struct ListNode* lt = (struct ListNode*)malloc(sizeof(struct ListNode)); lt-&gt;val = 0; lt-&gt;next = NULL; // 非小于x的部分 struct ListNode* mt = (struct ListNode*)malloc(sizeof(struct ListNode)); mt-&gt;val = 0; mt-&gt;next = NULL; struct ListNode* ph = head; struct ListNode* plt = lt; struct ListNode* pmt = mt; while(NULL != ph)&#123; if(ph-&gt;val &lt; x)&#123; plt-&gt;next = ph; plt = plt-&gt;next; ph = ph-&gt;next; plt-&gt;next = NULL; &#125;else&#123; pmt-&gt;next = ph; pmt = pmt-&gt;next; ph = ph-&gt;next; pmt-&gt;next = NULL; &#125; &#125; plt-&gt;next = mt-&gt;next; return lt-&gt;next;&#125;struct ListNode* partitionNo1(struct ListNode* head, int x)&#123; // 小于目标值部分 struct ListNode* l = (struct ListNode*)malloc(sizeof(struct ListNode)); // 设定初值 l-&gt;val = 0; l-&gt;next = NULL; // 非小于目标值部分 struct ListNode* r = (struct ListNode*)malloc(sizeof(struct ListNode)); // 设定初值 r-&gt;val = 0; r-&gt;next = NULL; // 操作指针 struct ListNode *p,*pl,*pr; p = head; pl = l; pr = r; while(p != NULL)&#123; if(p-&gt;val &lt; x)&#123; // 小于目标值 pl-&gt;next = p; pl = p; p = p-&gt;next; pl-&gt;next = NULL; &#125;else&#123; // 非小于目标值 pr-&gt;next = p; pr = p; p = p-&gt;next; pr-&gt;next = NULL; &#125; &#125; // 把大的部分链接到小的部分 pl-&gt;next = r-&gt;next; return l-&gt;next;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0507-完美数]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode0507-%E5%AE%8C%E7%BE%8E%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。 给定一个 正整数 n， 如果他是完美数，返回 True，否则返回 False 示例： 123输入: 28输出: True解释: 28 = 1 + 2 + 4 + 7 + 14 注意: 输入的数字 n 不会超过 100,000,000. (1e8) 解题思路​ 其实在leetcode中一般比较讨厌这种数学题，但是这个题还是比较简单的。无非就是求出所有的约数累加，若果等于输入返回true，如果不但能于输入返回false。最主要的问题是优化的问题，刚开始我尝试了很多次才提交成功，失败都是因为运行超时。 ​ 对于第一的代码。。。这种操作是否可以我不太了解，仅供参考吧。 代码实现12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;bool checkPerfectNumber(int num);// 排名第一的代码bool checkPerfectNumberNo1(int num);int main(int argc, char const *argv[])&#123; /* code */ int num = 28; bool res = checkPerfectNumber(num); printf("是否是完美数: %d \n", res); return 0;&#125;bool checkPerfectNumber(int num)&#123; if(num % 2 == 1) return false; int res = 0, i = 2; double con = (double)sqrt(num); while(i &lt;= con)&#123; if(num % i == 0) res += i + num / i; if(res &gt; num) return false; i++; &#125; res += 1; return (res == num)? true: false;&#125;bool checkPerfectNumberNo1(int num)&#123; if(num==6||num==28||num==496||num==8128||num==33550336) return true; return false;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>C语言</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0198-打家劫舍]]></title>
    <url>%2F2019%2F07%2F28%2Fleetcode0198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%2F</url>
    <content type="text"><![CDATA[问题描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路这里依然是一个典型的动态规划题目。设最大利润为：$ f(n) $ $ f(n) = max(f(n-1), f(n-2) + n) $ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int rob(int* nums, int numsSize);// 排名第一的答案int robNo1(int* nums, int numsSize);int main(int argc, char const *argv[])&#123; /* code */ int nums[] = &#123;1, 2, 3, 1&#125;; // int nums[] = &#123;2, 7, 9, 3, 1&#125;; int numsSize = 5; int res = rob(nums, numsSize); printf("结果: %d \n", res); return 0;&#125;int rob(int* nums, int numsSize)&#123; if(numsSize == 0 || NULL == nums) return 0; if(numsSize == 1) return nums[0]; int last = nums[0], tmp = 0; int max = (nums[0] &gt; nums[1])? nums[0]: nums[1]; for(int i = 2; i &lt; numsSize; i++)&#123; if(nums[i] + last &gt; max)&#123; tmp = max; max = nums[i] + last; last = tmp; &#125;else&#123; last = max; &#125; &#125; return max;&#125;int robNo1(int* nums, int numsSize)&#123; if(0 == numsSize || NULL == nums) return 0; if(1 == numsSize) return nums[0]; if(2 == numsSize) return (nums[0] &gt; nums[1])?nums[0]:nums[1]; int maxSum; int* maxSumArr = (int *)malloc(sizeof(int)* numsSize); memset(maxSumArr,0,sizeof(int)* numsSize); maxSumArr[0] = nums[0]; maxSumArr[1] = (nums[0] &gt; nums[1])?nums[0]:nums[1]; for(int i = 2; i &lt; numsSize; i++) &#123; if(maxSumArr[i-2] + nums[i] &gt; maxSumArr[i-1]) maxSumArr[i] = maxSumArr[i-2] + nums[i]; else maxSumArr[i] = maxSumArr[i-1]; &#125; maxSum = maxSumArr[numsSize-1]; free(maxSumArr); return maxSum;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>C语言</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0121-最佳买股票时机]]></title>
    <url>%2F2019%2F07%2F28%2Fleetcode0121-%E6%9C%80%E4%BD%B3%E4%B9%B0%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[问题描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路可用考虑使用动态优化。我们用数组中的后一个数减去前一个数，得到一个利润组合的数组。题目其实就是求该数组的最大子序列和。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;int maxProfit(int* prices, int pricesSize);// 排名第一的答案int maxProfitNo1(int* prices, int pricesSize);int main()&#123; int nums[] = &#123;7, 1, 5, 3, 6, 4&#125;; int pricesSize = 5; int res = maxProfit(nums, pricesSize); printf("最大利润为: %d \n", res); return 0;&#125;int maxProfit(int* prices, int pricesSize)&#123; // 数组长度为0或者1，返回0 if(pricesSize == 0 || pricesSize == 1) return 0; // 数组长度为2，返回利润差或者0 if(pricesSize == 2) return (prices[1] &lt; prices[0])? 0: (prices[1] - prices[0]); int bouns = 0, max = 0, res = 0; for(int i = 1; i &lt; pricesSize; i++)&#123; // 当日利润 bouns = prices[i] - prices[i-1]; max += bouns; if(max &gt; res)&#123; res = max; &#125;else if(max &lt; 0)&#123; max = 0; &#125; &#125; return res;&#125;int maxProfitNo1(int* prices, int pricesSize)&#123; if(pricesSize &lt;= 1) return 0; int max, min; for(int i=0;i&lt;pricesSize;i++)&#123; if(i==0)&#123; min = prices[0]; max = 0; &#125;else&#123; min = prices[i] &lt; min ? prices[i] : min; max = max &gt; prices[i] - min ? max : prices[i] - min; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>动态规划</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0053-最大子序和]]></title>
    <url>%2F2019%2F07%2F27%2Fleetcode0053-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[问题描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路最优解法是动态规划，其时间复杂度为O(n)。 代码实现123456789101112131415161718192021222324def maxSubArray(nums): if not nums: return 0 res, tmp = float('-inf'), 0 for num in nums: tmp += num if tmp &gt; res: res = tmp if tmp &lt; 0: tmp = 0 return resdef main(): nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] res = maxSubArray(nums) print(res)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0070-爬楼梯]]></title>
    <url>%2F2019%2F07%2F27%2Fleetcode0070-%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[问题描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 解题思路找一下规律，你会发现这个题的解其实就是一个菲波那切数。 假设楼梯有n阶，你爬上n有两种方式 当你在n-1阶时，爬1阶 当你在n-2阶时，爬2阶 由此可以看出，爬上n阶有多少中方法取决有爬上n-1和n-2阶有多少方法 递归下去，我们有以下公式 $ f(n) = f(n-1) + f(n-2) $ 条件: $ n &gt; 0 $ 这样一看就很明显了，这就是一个求取斐波那契切数的过程 代码实现1234567891011121314151617def climbStairs(n): a, b = 1, 1 while n &gt; 1: a, b = b, a+b n -= 1 return bdef main(): n = 3 res = climbStairs(n) print(res)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0013-罗马数字转整数]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode0013-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: &quot;III&quot;输出: 3 示例 2: 12输入: &quot;IV&quot;输出: 4 示例 3: 12输入: &quot;IX&quot;输出: 9 示例 4: 123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5: 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路本题很简单，个人感觉是在考察对于条件判断的掌握程度，如何将各种情况分开进行数值计算。 IV=4，IX=9 XL=40，XC=90 CD=400，CM=900 代码实现12345678910111213141516171819202122232425262728293031323334353637def romanToInt(s): # 定义字母数字对应法则 romanDict = &#123; 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 &#125; res = 0 for loc in range(len(s)): # 取出当前字母所对应的数值累加 res += romanDict[s[loc]] if loc &gt; 0: # 判断前一字母的影响 if s[loc-1] == 'I' and s[loc] in 'VX': res -= 2 elif s[loc-1] == 'X' and s[loc] in 'LC': res -= 20 elif s[loc-1] == 'C' and s[loc] in 'DM': res -= 200 return resdef main(): s = 'MCMXCIV' res = romanToInt(s) print(res)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0118-杨辉三角]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode0118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%2F</url>
    <content type="text"><![CDATA[问题描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解题思路如果使用两个数组处理累加的问题，问题非常简单。 当然也可以对数组进行原地操作，控制好边界就可以。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445def generate_1(numRows): cs = [] for m in range(numRows): s = [] for n in range(m + 1): if m== 0 or n == 0 or m == 1 or n == m: s.append(1) else: s.append(cs[m - 1][n-1] + cs[m-1][n]) cs.append(s) return csdef generate(numRows): res = [] if numRows == 0: return res if numRows &gt;= 1: res.append([1]) if numRows &gt;= 2: res.append([1,1]) h = 2 while h &lt; numRows: # 取出上一行 tmp = res[-1] # 前后各加一个0，两个数组对应相加 row = [a+b for a, b in zip([0]+tmp, tmp+[0])] res.append(row) h += 1 return resdef main(): numRows = 5 res = generate(numRows) print(res)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0172-阶乘后的零]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode0172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[问题描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解题思路阶乘操作是数字与数字之间的连乘，在0到9是个数字中，相乘等于零的组合有： 0和1到9之间的任何数 5和2，4，6，8的偶数 其中偶数可以看成是2与其他自然数的乘积。 所以本题的重点在于数字中5的个数： 每隔 5个，会产生一个0，比如 5， 10 ，15，20。 每隔 5×5 个会多产生出一个0，比如 25，50，75，100。 每隔 5×5×5 会多出一个0，比如125。 代码实现1234567891011121314151617181920212223242526272829def trailingZeroes(n): ''' 递归实现 ''' if n &lt; 5: return 0 else: return n // 5 + trailingZeroes(n // 5)def trailingZeroes_1(self, parameter_list): ''' 循环实现 ''' res = 0 while n: res = res + n // 5 n = n // 5 return resdef main(): n = 30 res = trailingZeroes(n) print(res)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0202-快乐数]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode0202-%E5%BF%AB%E4%B9%90%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 解题思路代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253def isHappy_1(n): # 记录是否出现重复平方和 rep_list = [] while True: # 求各个位数的平方和 tmp = 0 while n != 0: tmp = tmp + (n % 10) ** 2 n //= 10 if tmp == 1: # 等于1是快乐数 return True else: # 不等于1 if tmp not in rep_list: # 不重复，记入list rep_list.append(tmp) # n取tmp，进行下次运算 n = tmp else: # 重复返回False return Falsedef isHappy(n, rep_list = []): tmp = 0 while n != 0: tmp = tmp + (n % 10) ** 2 n //= 10 if tmp == 1: return True else: if tmp not in rep_list: rep_list.append(tmp) return isHappy(tmp, rep_list) else: return False def main(): n = 13 res = isHappy_1(n) print(res)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0344-反转字符串]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode0344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[问题描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 解题思路这个题其实很简单，最简单的三种方式： 逆向遍历输出 首尾依次交换 递归 作为一道简单题目，我们首先要考虑的是如何扩展它 代码实现123456789101112131415161718192021222324252627282930313233343536373839def reverseString_1(s): ''' 递归实现 长度等于1返回自身 长度大于1，后移一位递归 ''' # 空字符串不进行任何处理 if not s: return None if len(s) == 1: # 长度为1返回自身 return s[0] else: # 递归 + 首位 return reverseString(s[1:]) + s[0]def reverseString(s): ''' 首尾依次交换 ''' start, end = 0, len(s) - 1 while start &lt; end: tmp = s[start] s[start] = s[end] s[end] = tmp start += 1 end -= 1def main(): s = ["H","a","n","n","a","h"] print(reverseString(s))if __name__ == "__main__": main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0021-合并两个有序链表]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode0021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路这个题比较简单，思路很直接，两个有序链表从头开始比较就可以了，较小的添加到新的链表，一个链表遍历结束后，将剩下的链表直接拼接到新链表上即可。过程中注意判空就好了。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 定义节点class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createNodes(nums): ''' 根据数组创建链表 ''' if not nums: return None # 初始化头节点 head = ListNode(nums[0]) p, q = head, head for num in range(1, len(nums)): p = ListNode(nums[num]) q.next = p q = p return headdef printNodes(head): ''' 打印链表 ''' if not head: return None while head: print(head.val, end=' ') head = head.next print('')def mergeTwoLists(l1, l2): res = ListNode(None) node = res while l1 and l2: if l1.val &lt; l2.val: node.next, l1 = l1, l1.next else: node.next, l2 = l2, l2.next node = node.next if l1: node.next = l1 else: node.next = l2 return res.nextdef main(): nums1 = createNodes([1, 2, 4]) nums2 = createNodes([1, 3, 4]) res = mergeTwoLists(nums1, nums2) printNodes(res)if __name__ == '__main__': main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode0035-搜索插入位置]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode0035-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[问题描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 解题思路题目比较简单，可以分为两种： 从头开始遍历，找到合适的插入位置，返回结果 二分法查找所在位置 代码实现普通遍历12345678910111213141516171819202122232425262728def searchInsert(nums, target): length = len(nums) for i in range(length): num = nums[i] if target &lt;= num: # 小于等于返回当前位置 return i elif i == length - 1: # 查找到最后 return length elif nums[i+1] &gt; target: # 后一个值大于当前值 return i + 1 def mian(): nums = [1,3,5,6] target = 7 res = searchInsert(nums, target) print(res)if __name__ == "__main__": mian() 二分查找1234567891011121314151617181920212223242526272829303132333435363738394041424344def searchInsert(nums, target): # 数组为空返回0 if not nums: return 0 # 二分法查找 return binarySearch(nums, target, 0, len(nums)-1)def binarySearch(self, nums, target, start, end): ''' 二分法查找 @params nums: 查询数组 @params target: 目标值 @params start: 开始位置 @params end: 结束位置 @return loc: 插入所在位置 ''' # 只剩一个元素，且该元素大于等于目标值 if start == end and nums[start] &gt;= target: return start # 只剩一个元素，且该元素小于目标值 if start == end and nums[start] &lt; target: return start + 1 # 取中间位置 mid = (start + end) // 2 # 中间位置大于等于目标值，在后一半查找 if nums[mid] &gt;= target: return binarySearch(nums, target, start, mid) # 中间位置小于于目标值，在前一半查找 if nums[mid] &lt; target: return binarySearch(nums, target, mid+1, end)def mian(): nums = [1,3,5,6] target = 7 res = searchInsert(nums, target) print(res)if __name__ == "__main__": mian()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>python</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
